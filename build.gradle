import groovy.json.JsonSlurper

plugins {
    id 'org.springframework.boot' version '2.6.6' apply false
    id "com.github.spotbugs" version '5.0.6'
    id "com.diffplug.spotless" version "6.4.2" apply false
    id "io.freefair.lombok" version "6.4.2"
    id 'com.github.jk1.dependency-license-report' version '2.1'
}

def licenseFile3rdParty = 'LICENSE-3RD-PARTY.txt'

licenseReport {
    renderers = [
        new com.github.jk1.license.render.TextReportRenderer(licenseFile3rdParty),
    ]
    projects = [project]+ project.subprojects.findAll{it.name != 'veo-test'}
    filters = [
        new com.github.jk1.license.filter.LicenseBundleNormalizer()
    ]
}

def continuousIntegrationBuild = rootProject.hasProperty('ci')

allprojects  {
    group = 'org.veo'
    version = '0.15-SNAPSHOT'

    apply plugin: "com.diffplug.spotless"
    def currentUserName = "git config user.name".execute().text.trim() ?: "<name>"

    repositories {
        mavenCentral()
    }

    spotless {
        groovyGradle {
            // https://github.com/diffplug/spotless/issues/304#issuecomment-426067801
            target 'Jenkinsfile', '*.gradle'
            greclipse()
            indentWithSpaces(4)
            trimTrailingWhitespace()
        }
        java {
            target 'src/**/*.java', 'buildSrc/**/*.java'
            eclipse().configFile(rootProject.file('misc/eclipse/java-format.xml'))
            importOrderFile(rootProject.file('misc/eclipse/java.importorder'))
            addStep org.veo.LicenseHeaderStep.create(currentUserName)
            addStep org.veo.NoWildcardImportsStep.create()
            removeUnusedImports()
            trimTrailingWhitespace()
            replaceRegex('Consecutive empty block comment lines', /( *\*\n){2,}/, '*\n')
            replaceRegex('Empty line at block comment end', / \*\n *\*\//, ' */')
            replaceRegex('Empty comment block', /\/\*+\s+\*\//, '')
            replaceRegex('Empty line after annotation', /(^ +@[a-zA-Z0-9]+\([^)]+\)\n)\n+/, '$1')
            replaceRegex('Empty line inside annotation', /(^ +@[a-zA-Z0-9]+\([^)]+\n)\n+/, '$1')
            replaceRegex('Default value for Schema#required()', /((?<=@Schema\([^)]{1,500}), required = false)|((?<=@Schema\()required = false(, )?)/, '')
        }
        groovy {
            target 'src/**/*.groovy', 'buildSrc/**/*.groovy'
            addStep org.veo.LicenseHeaderStep.create(currentUserName)
            addStep org.veo.NoWildcardImportsStep.create()
            greclipse()
            importOrderFile(rootProject.file('misc/eclipse/java.importorder'))
            indentWithSpaces(4)
            trimTrailingWhitespace()
            replaceRegex('Extra space around equals sign', /(  += )|( =  +)/, ' = ')
            replaceRegex('Not one space between right round and left curly bracket', /\) *\{/, ') {')
        }
        format 'xml', {
            target 'src/**/*.xml', 'misc/eclipse/java-format.xml'
            eclipseWtp('xml')
        }
        format 'git', {
            target '**/.gitignore'

            trimTrailingWhitespace()
            endWithNewline()
        }
        format 'markdown', {
            target '**/*.md'
            targetExclude '**/bin/**', '**/target/**'
            trimTrailingWhitespace()
            indentWithTabs()
            endWithNewline()
        }
        format 'json', {
            target '**/*.json'
            targetExclude '**/bin/**', '**/target/**'
            eclipseWtp('json').configFile rootProject.file('misc/eclipse/json-format.prefs')
            endWithNewline()
        }
        format 'Jenkinsfile', {
            target 'Jenkinsfile'
            indentWithSpaces(4)
            endWithNewline()
            trimTrailingWhitespace()
        }
    }
}

// work around for license report not being updated when the project's version number changes
// https://github.com/jk1/Gradle-License-Report/issues/223

generateLicenseReport.outputs.with {
    upToDateWhen { false }
    cacheIf { false }
}

task copy3rdPartyLicenseFile {
    generateLicenseReport.finalizedBy it
    doLast {
        file(licenseFile3rdParty).text = file("${generateLicenseReport.config.outputDir}/${licenseFile3rdParty}").text
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'io.spring.dependency-management'
    apply plugin: 'com.github.spotbugs'
    apply plugin: 'pmd'
    apply plugin: 'jacoco'
    apply plugin: 'io.freefair.lombok'

    dependencyManagement {
        imports {
            mavenBom org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES
        }
    }

    dependencyManagement {
        dependencies {
            dependency 'com.vladmihalcea:hibernate-types-52:2.16.0'
            dependency 'io.jsonwebtoken:jjwt-api:0.11.2'
            dependency 'io.jsonwebtoken:jjwt-impl:0.11.2'
            dependency 'io.jsonwebtoken:jjwt-jackson:0.11.2'
            dependency "org.spockframework:spock-core:2.1-groovy-3.0"
            dependency "org.spockframework:spock-spring:2.1-groovy-3.0"
            dependency 'org.springdoc:springdoc-openapi-ui:1.6.6'
            dependency 'org.springdoc:springdoc-openapi-common:1.6.6'
            dependency 'io.swagger.core.v3:swagger-core:2.1.13'
            dependency 'io.swagger.core.v3:swagger-annotations:2.1.13'
            dependency 'net.ttddyy:datasource-proxy:1.7'
            dependency 'com.github.victools:jsonschema-generator:4.24.2'
            dependency 'com.github.victools:jsonschema-module-jackson:4.24.2'
            dependency 'com.github.victools:jsonschema-module-javax-validation:4.24.2'
            dependency 'com.github.victools:jsonschema-module-swagger-2:4.24.2'
            dependency 'com.networknt:json-schema-validator:1.0.67'
            dependency "org.testcontainers:spock:1.17.0"
            dependency "org.testcontainers:postgresql:1.17.0"
            dependency "org.keycloak:keycloak-authz-client:16.1.1"
            dependency "com.github.JanLoebel:json-schema-validation-starter:2.3.0"
            dependency 'com.fasterxml.uuid:java-uuid-generator:4.0.1'
            dependency 'commons-cli:commons-cli:1.5.0'
            dependency 'org.freemarker:freemarker:2.3.31'
        }
    }

    sourceCompatibility = 11
    targetCompatibility = 11

    tasks.withType(JavaCompile) { options.encoding = 'UTF-8' }

    repositories {
        maven { url 'https://jitpack.io' }
    }

    tasks.withType(Test) {
        useJUnitPlatform()
        systemProperties project.properties.subMap([
            "http.proxyHost",
            "http.proxyPort",
            "https.proxyHost",
            "https.proxyPort"
        ])
    }

    pmd {
        toolVersion = '6.43.0'
        ruleSetConfig = rootProject.resources.text.fromFile('misc/pmd/rules.xml')
        ruleSets = []
        rulesMinimumPriority = 2
        consoleOutput = true
        sourceSets = project.sourceSets.matching {it.name != 'test'}
    }

    spotbugs.excludeFilter = rootProject.file('misc/spotbugs/exclude.xml')
    spotbugsTest.enabled = false
    // write human readable report on normal builds
    spotbugsMain.reports {
        // Jenkins needs xml reports to detect and display bugs.
        xml.enabled = continuousIntegrationBuild
        html.enabled = !continuousIntegrationBuild
    }

    // specific "continuous integration" settings needed by Jenkins
    if (continuousIntegrationBuild) {

        // The recordIssues Jenkins plugin reads from the console output, so we need to write the warnings
        // on every build. Otherwise Jenkins will assume the warnings have been fixed.
        tasks.withType(JavaCompile) {
            outputs.upToDateWhen { false }
        }

        tasks.withType(Test) {
            // Don't let failing tests fail the build, let the junit step in the Jenkins pipeline decide what to do
            ignoreFailures = true
            testLogging {
                showStandardStreams = true
                exceptionFormat = 'full'
            }
        }

        // Update the test result file timestamps so Jenkins picks them up even when doing incremental builds
        task jenkinsTestFix {
            inputs.files test.outputs.files
            doLast {
                if (!sourceSets.test.allSource.empty) {
                    def timestamp = System.currentTimeMillis()
                    test.reports.junitXml.outputLocation.get().asFile.eachFile { it.lastModified = timestamp }
                }
            }
        }

        test {
            finalizedBy jenkinsTestFix
        }
    }

    dependencies {
        compileOnly 'org.slf4j:slf4j-api'
        runtimeOnly 'ch.qos.logback:logback-classic'
        spotbugsPlugins "jp.skypencil.findbugs.slf4j:bug-pattern:1.5.0@jar"
        spotbugsPlugins 'com.h3xstream.findsecbugs:findsecbugs-plugin:1.12.0'
    }

    tasks.withType(JavaCompile) {
        configure(options){
            debugOptions.debugLevel = "source,lines,vars"
            // See https://docs.oracle.com/en/java/javase/11/tools/javac.html#GUID-AEEC9F07-CB49-4E96-8BC7-BCC2C7F725C9
            // for a detailed list of linting keys.
            compilerArgs.addAll([
                '-Xlint:all',
                '-Xlint:-serial'
            ])
        }
    }
}

task checkTranslations {
    def domainTemplates = rootProject.file('domaintemplates')
    inputs.files domainTemplates

    doLast {
        def missingTranslations = false

        domainTemplates.eachFile { templateDir ->
            logger.info "Checking translations for $templateDir"
            def typeDirs = new File(templateDir, 'types').listFiles()

            typeDirs.each {typeDir->
                def customAspectAndLinkFiles = fileTree(typeDir){
                    include 'links/*.json'
                    include 'customAspects/*.json'
                }
                def subTypeFiles = fileTree(dir: typeDir, include: 'subTypes/*.json')
                def langFile = new File(typeDir, 'lang.json')
                def langJson = new JsonSlurper().parse(langFile)

                def languagesToCheck = [
                    'German': langJson.de,
                    'English': langJson.en
                ]

                def handleTranslationKey = { String translationKey, location = null ->
                    languagesToCheck.each {lang, json->
                        def translation = json.remove(translationKey)
                        if (translation == null) {
                            logger.warn("$langFile: Missing $lang translation for $translationKey in $location")
                            missingTranslations = true
                        }
                    }
                }

                // Nameable base attributes
                handleTranslationKey('name', 'Nameable base attributes')
                handleTranslationKey('abbreviation', 'Nameable base attributes')
                handleTranslationKey('description', 'Nameable base attributes')

                customAspectAndLinkFiles.each { file->

                    logger.info "Loading $file"
                    def data = new JsonSlurper().parse(file)
                    def isLinkSchema = file.parentFile.name == 'links'
                    if (isLinkSchema) {
                        // link IDs should be translated, custom aspect IDs should not
                        handleTranslationKey(file.name.replace(".json", ""), "$file.name (custom link id)")
                    }

                    def properties = data.attributeSchemas
                    def propertyNames = properties.keySet()
                    logger.info "property names: $propertyNames"

                    // custom aspect attribute ID / field in the editor
                    properties.each {key, value->
                        handleTranslationKey(key, "$file.name (custom aspect/link attribute id)")
                        // custom aspect enum entry / value in drop-down
                        value.enum?.each {
                            handleTranslationKey(it, "$file.name (custom aspect/link select value id)")
                        }
                        // custom aspect enum entry / value in multi-value drop-down
                        value.items?.enum?.each {
                            handleTranslationKey(it, "$file.name (custom aspect/link select value id)")
                        }
                    }
                }

                subTypeFiles.each { File subTypeFile ->
                    def type = subTypeFile.parentFile.parentFile.name.toLowerCase()
                    def subType = subTypeFile.name[0..-6]
                    new JsonSlurper().parse(subTypeFile).statuses.each{ status ->
                        handleTranslationKey("${type}_${subType}_status_${status}", subTypeFile.absolutePath)
                    }
                }

                languagesToCheck.each {lang, json->
                    json.each {
                        logger.warn("$langFile: Unused $lang translation $it")
                    }
                }
            }
        }

        if (missingTranslations) {
            throw new GradleException("There are translations missing, see log output above.")
        }
    }
}

task check {
    dependsOn checkTranslations
}
